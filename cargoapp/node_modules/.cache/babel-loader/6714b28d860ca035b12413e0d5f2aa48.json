{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.from.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.genPoints = genPoints;\nexports.genBars = genBars;\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction genPoints(values, boundary) {\n  var minX = boundary.minX,\n      maxX = boundary.maxX,\n      minY = boundary.minY,\n      maxY = boundary.maxY;\n  var totalValues = values.length;\n  var maxValue = Math.max.apply(Math, _toConsumableArray(values));\n  var minValue = Math.min.apply(Math, _toConsumableArray(values));\n  var gridX = (maxX - minX) / (totalValues - 1);\n  var gridY = (maxY - minY) / (maxValue - minValue || 1);\n  return values.map(function (value, index) {\n    return {\n      x: minX + index * gridX,\n      y: maxY - (value - minValue) * gridY,\n      value: value\n    };\n  });\n}\n\nfunction genBars(values, boundary) {\n  var minX = boundary.minX,\n      maxX = boundary.maxX,\n      minY = boundary.minY,\n      maxY = boundary.maxY;\n  var totalValues = values.length;\n  var maxValue = Math.max.apply(Math, _toConsumableArray(values));\n  var minValue = Math.min.apply(Math, _toConsumableArray(values));\n  if (minValue > 0) minValue = 0;\n  if (maxValue < 0) maxValue = 0;\n  var gridX = maxX / totalValues;\n  var gridY = (maxY - minY) / (maxValue - minValue || 1);\n  var horizonY = maxY - Math.abs(minValue * gridY);\n  return values.map(function (value, index) {\n    var height = Math.abs(gridY * value);\n    return {\n      x: minX + index * gridX,\n      y: horizonY - height + +(value < 0) * height,\n      height: height,\n      value: value\n    };\n  });\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEM,SAAUA,SAAV,CACJC,MADI,EAEJC,QAFI,EAEc;EAAA,IAEVC,IAFU,GAEiBD,QAFjB,CAEVC,IAFU;EAAA,IAEJC,IAFI,GAEiBF,QAFjB,CAEJE,IAFI;EAAA,IAEEC,IAFF,GAEiBH,QAFjB,CAEEG,IAFF;EAAA,IAEQC,IAFR,GAEiBJ,QAFjB,CAEQI,IAFR;EAGlB,IAAMC,WAAW,GAAGN,MAAM,CAACO,MAA3B;EACA,IAAMC,QAAQ,GAAGC,IAAI,CAACC,GAAL,aAAIC,mBAAQX,MAAR,CAAJ,CAAjB;EACA,IAAMY,QAAQ,GAAGH,IAAI,CAACI,GAAL,aAAIF,mBAAQX,MAAR,CAAJ,CAAjB;EAEA,IAAMc,KAAK,GAAG,CAACX,IAAI,GAAGD,IAAR,KAAiBI,WAAW,GAAG,CAA/B,CAAd;EACA,IAAMS,KAAK,GAAG,CAACV,IAAI,GAAGD,IAAR,KAAkBI,QAAQ,GAAGI,QAAX,IAAwB,CAA1C,CAAd;EAEA,OAAOZ,MAAM,CAACgB,GAAP,CAAW,UAACC,KAAD,EAAQC,KAAR,EAAiB;IACjC,OAAO;MACLC,CAAC,EAAEjB,IAAI,GAAGgB,KAAK,GAAGJ,KADb;MAELM,CAAC,EAAEf,IAAI,GAAG,CAACY,KAAK,GAAGL,QAAT,IAAqBG,KAF1B;MAGLE,KAAK,EAALA;IAHK,CAAP;EADK,EAAP;AAOD;;AAEK,SAAUI,OAAV,CACJrB,MADI,EAEJC,QAFI,EAEc;EAAA,IAEVC,IAFU,GAEiBD,QAFjB,CAEVC,IAFU;EAAA,IAEJC,IAFI,GAEiBF,QAFjB,CAEJE,IAFI;EAAA,IAEEC,IAFF,GAEiBH,QAFjB,CAEEG,IAFF;EAAA,IAEQC,IAFR,GAEiBJ,QAFjB,CAEQI,IAFR;EAGlB,IAAMC,WAAW,GAAGN,MAAM,CAACO,MAA3B;EACA,IAAIC,QAAQ,GAAGC,IAAI,CAACC,GAAL,aAAIC,mBAAQX,MAAR,CAAJ,CAAf;EACA,IAAIY,QAAQ,GAAGH,IAAI,CAACI,GAAL,aAAIF,mBAAQX,MAAR,CAAJ,CAAf;EAEA,IAAIY,QAAQ,GAAG,CAAf,EAAkBA,QAAQ,GAAG,CAAX;EAClB,IAAIJ,QAAQ,GAAG,CAAf,EAAkBA,QAAQ,GAAG,CAAX;EAElB,IAAMM,KAAK,GAAGX,IAAI,GAAGG,WAArB;EACA,IAAMS,KAAK,GAAG,CAACV,IAAI,GAAGD,IAAR,KAAkBI,QAAQ,GAAGI,QAAX,IAAwB,CAA1C,CAAd;EACA,IAAMU,QAAQ,GAAGjB,IAAI,GAAGI,IAAI,CAACc,GAAL,CAASX,QAAQ,GAAGG,KAApB,CAAxB;EAEA,OAAOf,MAAM,CAACgB,GAAP,CAAW,UAACC,KAAD,EAAQC,KAAR,EAAiB;IACjC,IAAMM,MAAM,GAAGf,IAAI,CAACc,GAAL,CAASR,KAAK,GAAGE,KAAjB,CAAf;IAEA,OAAO;MACLE,CAAC,EAAEjB,IAAI,GAAGgB,KAAK,GAAGJ,KADb;MAELM,CAAC,EAAEE,QAAQ,GAAGE,MAAX,GACD,EAAEP,KAAK,GAAG,CAAV,IAAeO,MAHZ;MAILA,MAAM,EAANA,MAJK;MAKLP,KAAK,EAALA;IALK,CAAP;EAHK,EAAP;AAWD","names":["genPoints","values","boundary","minX","maxX","minY","maxY","totalValues","length","maxValue","Math","max","_toConsumableArray","minValue","min","gridX","gridY","map","value","index","x","y","genBars","horizonY","abs","height"],"sourceRoot":"","sources":["../../../../src/components/VSparkline/helpers/core.ts"],"sourcesContent":["import { Point, Boundary, Bar } from '../VSparkline'\n\nexport function genPoints (\n  values: number[],\n  boundary: Boundary\n): Point[] {\n  const { minX, maxX, minY, maxY } = boundary\n  const totalValues = values.length\n  const maxValue = Math.max(...values)\n  const minValue = Math.min(...values)\n\n  const gridX = (maxX - minX) / (totalValues - 1)\n  const gridY = (maxY - minY) / ((maxValue - minValue) || 1)\n\n  return values.map((value, index) => {\n    return {\n      x: minX + index * gridX,\n      y: maxY - (value - minValue) * gridY,\n      value,\n    }\n  })\n}\n\nexport function genBars (\n  values: number[],\n  boundary: Boundary\n): Bar[] {\n  const { minX, maxX, minY, maxY } = boundary\n  const totalValues = values.length\n  let maxValue = Math.max(...values)\n  let minValue = Math.min(...values)\n\n  if (minValue > 0) minValue = 0\n  if (maxValue < 0) maxValue = 0\n\n  const gridX = maxX / totalValues\n  const gridY = (maxY - minY) / ((maxValue - minValue) || 1)\n  const horizonY = maxY - Math.abs(minValue * gridY)\n\n  return values.map((value, index) => {\n    const height = Math.abs(gridY * value)\n\n    return {\n      x: minX + index * gridX,\n      y: horizonY - height +\n        +(value < 0) * height,\n      height,\n      value,\n    }\n  })\n}\n"]},"metadata":{},"sourceType":"script"}