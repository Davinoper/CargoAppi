{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.object.keys.js\");\n\nrequire(\"core-js/modules/es.array.filter.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptors.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nrequire(\"core-js/modules/es.array.find.js\");\n\nrequire(\"core-js/modules/es.string.ends-with.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.string.includes.js\");\n\nrequire(\"core-js/modules/es.array.find-index.js\");\n\nrequire(\"core-js/modules/es.array.splice.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nrequire(\"../../../src/components/VAutocomplete/VAutocomplete.sass\");\n\nvar _VSelect = _interopRequireDefault(require(\"../VSelect/VSelect\"));\n\nvar _VAutocomplete2 = _interopRequireDefault(require(\"../VAutocomplete/VAutocomplete\"));\n\nvar _helpers = require(\"../../util/helpers\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/* @vue/component */\n\n\nvar _default2 = _VAutocomplete2.default.extend({\n  name: 'v-combobox',\n  props: {\n    delimiters: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    returnObject: {\n      type: Boolean,\n      default: true\n    }\n  },\n  data: function data() {\n    return {\n      editingIndex: -1\n    };\n  },\n  computed: {\n    computedCounterValue: function computedCounterValue() {\n      return this.multiple ? this.selectedItems.length : (this.internalSearch || '').toString().length;\n    },\n    hasSlot: function hasSlot() {\n      return _VSelect.default.options.computed.hasSlot.call(this) || this.multiple;\n    },\n    isAnyValueAllowed: function isAnyValueAllowed() {\n      return true;\n    },\n    menuCanShow: function menuCanShow() {\n      if (!this.isFocused) return false;\n      return this.hasDisplayedItems || !!this.$slots['no-data'] && !this.hideNoData;\n    },\n    searchIsDirty: function searchIsDirty() {\n      return this.internalSearch != null;\n    }\n  },\n  methods: {\n    onInternalSearchChanged: function onInternalSearchChanged(val) {\n      if (val && this.multiple && this.delimiters.length) {\n        var delimiter = this.delimiters.find(function (d) {\n          return val.endsWith(d);\n        });\n\n        if (delimiter != null) {\n          this.internalSearch = val.slice(0, val.length - delimiter.length);\n          this.updateTags();\n        }\n      }\n\n      this.updateMenuDimensions();\n    },\n    genInput: function genInput() {\n      var input = _VAutocomplete2.default.options.methods.genInput.call(this);\n\n      delete input.data.attrs.name;\n      input.data.on.paste = this.onPaste;\n      return input;\n    },\n    genChipSelection: function genChipSelection(item, index) {\n      var _this = this;\n\n      var chip = _VSelect.default.options.methods.genChipSelection.call(this, item, index); // Allow user to update an existing value\n\n\n      if (this.multiple) {\n        chip.componentOptions.listeners = _objectSpread(_objectSpread({}, chip.componentOptions.listeners), {}, {\n          dblclick: function dblclick() {\n            _this.editingIndex = index;\n            _this.internalSearch = _this.getText(item);\n            _this.selectedIndex = -1;\n          }\n        });\n      }\n\n      return chip;\n    },\n    onChipInput: function onChipInput(item) {\n      _VSelect.default.options.methods.onChipInput.call(this, item);\n\n      this.editingIndex = -1;\n    },\n    // Requires a manual definition\n    // to overwrite removal in v-autocomplete\n    onEnterDown: function onEnterDown(e) {\n      e.preventDefault(); // If has menu index, let v-select-list handle\n\n      if (this.getMenuIndex() > -1) return;\n      this.$nextTick(this.updateSelf);\n    },\n    onKeyDown: function onKeyDown(e) {\n      var keyCode = e.keyCode;\n\n      if (e.ctrlKey || ![_helpers.keyCodes.home, _helpers.keyCodes.end].includes(keyCode)) {\n        _VSelect.default.options.methods.onKeyDown.call(this, e);\n      } // If user is at selection index of 0\n      // create a new tag\n\n\n      if (this.multiple && keyCode === _helpers.keyCodes.left && this.$refs.input.selectionStart === 0) {\n        this.updateSelf();\n      } else if (keyCode === _helpers.keyCodes.enter) {\n        this.onEnterDown(e);\n      } // The ordering is important here\n      // allows new value to be updated\n      // and then moves the index to the\n      // proper location\n\n\n      this.changeSelectedIndex(keyCode);\n    },\n    onTabDown: function onTabDown(e) {\n      // When adding tags, if searching and\n      // there is not a filtered options,\n      // add the value to the tags list\n      if (this.multiple && this.internalSearch && this.getMenuIndex() === -1) {\n        e.preventDefault();\n        e.stopPropagation();\n        return this.updateTags();\n      }\n\n      _VAutocomplete2.default.options.methods.onTabDown.call(this, e);\n    },\n    selectItem: function selectItem(item) {\n      // Currently only supports items:<string[]>\n      if (this.editingIndex > -1) {\n        this.updateEditing();\n      } else {\n        _VAutocomplete2.default.options.methods.selectItem.call(this, item); // if selected item contains search value,\n        // remove the search string\n\n\n        if (this.internalSearch && this.multiple && this.getText(item).toLocaleLowerCase().includes(this.internalSearch.toLocaleLowerCase())) {\n          this.internalSearch = null;\n        }\n      }\n    },\n    setSelectedItems: function setSelectedItems() {\n      if (this.internalValue == null || this.internalValue === '') {\n        this.selectedItems = [];\n      } else {\n        this.selectedItems = this.multiple ? this.internalValue : [this.internalValue];\n      }\n    },\n    setValue: function setValue(value) {\n      _VSelect.default.options.methods.setValue.call(this, value === undefined ? this.internalSearch : value);\n    },\n    updateEditing: function updateEditing() {\n      var _this2 = this;\n\n      var value = this.internalValue.slice();\n      var index = this.selectedItems.findIndex(function (item) {\n        return _this2.getText(item) === _this2.internalSearch;\n      }); // If user enters a duplicate text on chip edit,\n      // don't add it, move it to the end of the list\n\n      if (index > -1) {\n        var item = _typeof(value[index]) === 'object' ? Object.assign({}, value[index]) : value[index];\n        value.splice(index, 1);\n        value.push(item);\n      } else {\n        value[this.editingIndex] = this.internalSearch;\n      }\n\n      this.setValue(value);\n      this.editingIndex = -1;\n      this.internalSearch = null;\n    },\n    updateCombobox: function updateCombobox() {\n      // If search is not dirty, do nothing\n      if (!this.searchIsDirty) return; // The internal search is not matching\n      // the internal value, update the input\n\n      if (this.internalSearch !== this.getText(this.internalValue)) this.setValue(); // Reset search if using slot to avoid a double input\n\n      var isUsingSlot = Boolean(this.$scopedSlots.selection) || this.hasChips;\n      if (isUsingSlot) this.internalSearch = null;\n    },\n    updateSelf: function updateSelf() {\n      this.multiple ? this.updateTags() : this.updateCombobox();\n    },\n    updateTags: function updateTags() {\n      var _this3 = this;\n\n      var menuIndex = this.getMenuIndex(); // If the user is not searching\n      // and no menu item is selected\n      // or if the search is empty\n      // do nothing\n\n      if (menuIndex < 0 && !this.searchIsDirty || !this.internalSearch) return;\n\n      if (this.editingIndex > -1) {\n        return this.updateEditing();\n      }\n\n      var index = this.selectedItems.findIndex(function (item) {\n        return _this3.internalSearch === _this3.getText(item);\n      }); // If the duplicate item is an object,\n      // copy it, so that it can be added again later\n\n      var itemToSelect = index > -1 && _typeof(this.selectedItems[index]) === 'object' ? Object.assign({}, this.selectedItems[index]) : this.internalSearch; // If it already exists, do nothing\n      // this might need to change to bring\n      // the duplicated item to the last entered\n\n      if (index > -1) {\n        var internalValue = this.internalValue.slice();\n        internalValue.splice(index, 1);\n        this.setValue(internalValue);\n      } // If menu index is greater than 1\n      // the selection is handled elsewhere\n      // TODO: find out where\n\n\n      if (menuIndex > -1) return this.internalSearch = null;\n      this.selectItem(itemToSelect);\n      this.internalSearch = null;\n    },\n    onPaste: function onPaste(event) {\n      var _event$clipboardData;\n\n      if (!this.multiple || this.searchIsDirty) return;\n      var pastedItemText = (_event$clipboardData = event.clipboardData) == null ? void 0 : _event$clipboardData.getData('text/vnd.vuetify.autocomplete.item+plain');\n\n      if (pastedItemText && this.findExistingIndex(pastedItemText) === -1) {\n        event.preventDefault();\n\n        _VSelect.default.options.methods.selectItem.call(this, pastedItemText);\n      }\n    },\n    clearableCallback: function clearableCallback() {\n      this.editingIndex = -1;\n\n      _VAutocomplete2.default.options.methods.clearableCallback.call(this);\n    }\n  }\n});\n\nexports.default = _default2;","map":{"version":3,"mappings":"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","names":["require","_VAutocomplete2","extend","name","props","delimiters","type","Array","default","returnObject","Boolean","data","editingIndex","computed","computedCounterValue","multiple","selectedItems","length","internalSearch","toString","hasSlot","_VSelect","options","call","isAnyValueAllowed","menuCanShow","isFocused","hasDisplayedItems","$slots","hideNoData","searchIsDirty","methods","onInternalSearchChanged","val","delimiter","find","endsWith","d","slice","updateTags","updateMenuDimensions","genInput","input","attrs","on","paste","onPaste","genChipSelection","item","index","chip","componentOptions","listeners","dblclick","_this","getText","selectedIndex","onChipInput","onEnterDown","e","preventDefault","getMenuIndex","$nextTick","updateSelf","onKeyDown","keyCode","ctrlKey","_helpers","home","end","includes","left","$refs","selectionStart","enter","changeSelectedIndex","onTabDown","stopPropagation","selectItem","updateEditing","toLocaleLowerCase","setSelectedItems","internalValue","setValue","value","undefined","findIndex","_this2","_typeof","Object","assign","splice","push","updateCombobox","isUsingSlot","$scopedSlots","selection","hasChips","menuIndex","_this3","itemToSelect","event","pastedItemText","clipboardData","_event$clipboardData","getData","findExistingIndex","clearableCallback"],"sourceRoot":"","sources":["../../../src/components/VCombobox/VCombobox.ts"],"sourcesContent":["// Styles\nimport '../VAutocomplete/VAutocomplete.sass'\n\n// Extensions\nimport VSelect from '../VSelect/VSelect'\nimport VAutocomplete from '../VAutocomplete/VAutocomplete'\n\n// Utils\nimport { keyCodes } from '../../util/helpers'\n\n// Types\nimport { PropValidator } from 'vue/types/options'\n\n/* @vue/component */\nexport default VAutocomplete.extend({\n  name: 'v-combobox',\n\n  props: {\n    delimiters: {\n      type: Array,\n      default: () => ([]),\n    } as PropValidator<string[]>,\n    returnObject: {\n      type: Boolean,\n      default: true,\n    },\n  },\n\n  data: () => ({\n    editingIndex: -1,\n  }),\n\n  computed: {\n    computedCounterValue (): number {\n      return this.multiple\n        ? this.selectedItems.length\n        : (this.internalSearch || '').toString().length\n    },\n    hasSlot (): boolean {\n      return VSelect.options.computed.hasSlot.call(this) || this.multiple\n    },\n    isAnyValueAllowed (): boolean {\n      return true\n    },\n    menuCanShow (): boolean {\n      if (!this.isFocused) return false\n\n      return this.hasDisplayedItems ||\n        (!!this.$slots['no-data'] && !this.hideNoData)\n    },\n    searchIsDirty (): boolean {\n      return this.internalSearch != null\n    },\n  },\n\n  methods: {\n    onInternalSearchChanged (val: any) {\n      if (\n        val &&\n        this.multiple &&\n        this.delimiters.length\n      ) {\n        const delimiter = this.delimiters.find(d => val.endsWith(d))\n        if (delimiter != null) {\n          this.internalSearch = val.slice(0, val.length - delimiter.length)\n          this.updateTags()\n        }\n      }\n\n      this.updateMenuDimensions()\n    },\n    genInput () {\n      const input = VAutocomplete.options.methods.genInput.call(this)\n\n      delete input.data!.attrs!.name\n      input.data!.on!.paste = this.onPaste\n\n      return input\n    },\n    genChipSelection (item: object, index: number) {\n      const chip = VSelect.options.methods.genChipSelection.call(this, item, index)\n\n      // Allow user to update an existing value\n      if (this.multiple) {\n        chip.componentOptions!.listeners! = {\n          ...chip.componentOptions!.listeners!,\n          dblclick: () => {\n            this.editingIndex = index\n            this.internalSearch = this.getText(item)\n            this.selectedIndex = -1\n          },\n        }\n      }\n\n      return chip\n    },\n    onChipInput (item: object) {\n      VSelect.options.methods.onChipInput.call(this, item)\n\n      this.editingIndex = -1\n    },\n    // Requires a manual definition\n    // to overwrite removal in v-autocomplete\n    onEnterDown (e: Event) {\n      e.preventDefault()\n      // If has menu index, let v-select-list handle\n      if (this.getMenuIndex() > -1) return\n\n      this.$nextTick(this.updateSelf)\n    },\n    onKeyDown (e: KeyboardEvent) {\n      const keyCode = e.keyCode\n\n      if (\n        e.ctrlKey ||\n        ![keyCodes.home, keyCodes.end].includes(keyCode)\n      ) {\n        VSelect.options.methods.onKeyDown.call(this, e)\n      }\n\n      // If user is at selection index of 0\n      // create a new tag\n      if (this.multiple &&\n        keyCode === keyCodes.left &&\n        this.$refs.input.selectionStart === 0\n      ) {\n        this.updateSelf()\n      } else if (keyCode === keyCodes.enter) {\n        this.onEnterDown(e)\n      }\n\n      // The ordering is important here\n      // allows new value to be updated\n      // and then moves the index to the\n      // proper location\n      this.changeSelectedIndex(keyCode)\n    },\n    onTabDown (e: KeyboardEvent) {\n      // When adding tags, if searching and\n      // there is not a filtered options,\n      // add the value to the tags list\n      if (this.multiple &&\n        this.internalSearch &&\n        this.getMenuIndex() === -1\n      ) {\n        e.preventDefault()\n        e.stopPropagation()\n\n        return this.updateTags()\n      }\n\n      VAutocomplete.options.methods.onTabDown.call(this, e)\n    },\n    selectItem (item: object) {\n      // Currently only supports items:<string[]>\n      if (this.editingIndex > -1) {\n        this.updateEditing()\n      } else {\n        VAutocomplete.options.methods.selectItem.call(this, item)\n\n        // if selected item contains search value,\n        // remove the search string\n        if (\n          this.internalSearch &&\n          this.multiple &&\n          this.getText(item).toLocaleLowerCase().includes(this.internalSearch.toLocaleLowerCase())\n        ) {\n          this.internalSearch = null\n        }\n      }\n    },\n    setSelectedItems () {\n      if (this.internalValue == null ||\n        this.internalValue === ''\n      ) {\n        this.selectedItems = []\n      } else {\n        this.selectedItems = this.multiple ? this.internalValue : [this.internalValue]\n      }\n    },\n    setValue (value?: any) {\n      VSelect.options.methods.setValue.call(this, value === undefined ? this.internalSearch : value)\n    },\n    updateEditing () {\n      const value = this.internalValue.slice()\n      const index = this.selectedItems.findIndex(item =>\n        this.getText(item) === this.internalSearch)\n\n      // If user enters a duplicate text on chip edit,\n      // don't add it, move it to the end of the list\n      if (index > -1) {\n        const item = typeof value[index] === 'object'\n          ? Object.assign({}, value[index])\n          : value[index]\n\n        value.splice(index, 1)\n        value.push(item)\n      } else {\n        value[this.editingIndex] = this.internalSearch\n      }\n\n      this.setValue(value)\n      this.editingIndex = -1\n      this.internalSearch = null\n    },\n    updateCombobox () {\n      // If search is not dirty, do nothing\n      if (!this.searchIsDirty) return\n\n      // The internal search is not matching\n      // the internal value, update the input\n      if (this.internalSearch !== this.getText(this.internalValue)) this.setValue()\n\n      // Reset search if using slot to avoid a double input\n      const isUsingSlot = Boolean(this.$scopedSlots.selection) || this.hasChips\n      if (isUsingSlot) this.internalSearch = null\n    },\n    updateSelf () {\n      this.multiple ? this.updateTags() : this.updateCombobox()\n    },\n    updateTags () {\n      const menuIndex = this.getMenuIndex()\n\n      // If the user is not searching\n      // and no menu item is selected\n      // or if the search is empty\n      // do nothing\n      if ((menuIndex < 0 && !this.searchIsDirty) ||\n          !this.internalSearch) return\n\n      if (this.editingIndex > -1) {\n        return this.updateEditing()\n      }\n\n      const index = this.selectedItems.findIndex(item =>\n        this.internalSearch === this.getText(item))\n\n      // If the duplicate item is an object,\n      // copy it, so that it can be added again later\n      const itemToSelect = index > -1 && typeof this.selectedItems[index] === 'object'\n        ? Object.assign({}, this.selectedItems[index])\n        : this.internalSearch\n\n      // If it already exists, do nothing\n      // this might need to change to bring\n      // the duplicated item to the last entered\n      if (index > -1) {\n        const internalValue = this.internalValue.slice()\n        internalValue.splice(index, 1)\n\n        this.setValue(internalValue)\n      }\n\n      // If menu index is greater than 1\n      // the selection is handled elsewhere\n      // TODO: find out where\n      if (menuIndex > -1) return (this.internalSearch = null)\n\n      this.selectItem(itemToSelect)\n\n      this.internalSearch = null\n    },\n    onPaste (event: ClipboardEvent) {\n      if (!this.multiple || this.searchIsDirty) return\n\n      const pastedItemText = event.clipboardData?.getData('text/vnd.vuetify.autocomplete.item+plain')\n      if (pastedItemText && this.findExistingIndex(pastedItemText as any) === -1) {\n        event.preventDefault()\n        VSelect.options.methods.selectItem.call(this, pastedItemText as any)\n      }\n    },\n    clearableCallback () {\n      this.editingIndex = -1\n\n      VAutocomplete.options.methods.clearableCallback.call(this)\n    },\n  },\n})\n"]},"metadata":{},"sourceType":"script"}