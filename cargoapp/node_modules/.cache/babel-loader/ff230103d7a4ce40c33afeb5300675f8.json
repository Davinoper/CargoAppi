{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.weak-map.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.from.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.object.keys.js\");\n\nrequire(\"core-js/modules/es.array.filter.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptors.js\");\n\nrequire(\"core-js/modules/es.set.js\");\n\nrequire(\"core-js/modules/es.string.search.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.map.js\");\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nrequire(\"../../../src/components/VTreeview/VTreeview.sass\");\n\nvar _VTreeviewNode = _interopRequireWildcard(require(\"./VTreeviewNode\"));\n\nvar _themeable = _interopRequireDefault(require(\"../../mixins/themeable\"));\n\nvar _registrable = require(\"../../mixins/registrable\");\n\nvar _helpers = require(\"../../util/helpers\");\n\nvar _mixins = _interopRequireDefault(require(\"../../util/mixins\"));\n\nvar _console = require(\"../../util/console\");\n\nvar _filterTreeItems = require(\"./util/filterTreeItems\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar _default2 = (0, _mixins.default)((0, _registrable.provide)('treeview'), _themeable.default\n/* @vue/component */\n).extend({\n  name: 'v-treeview',\n  provide: function provide() {\n    return {\n      treeview: this\n    };\n  },\n  props: _objectSpread({\n    active: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    dense: Boolean,\n    disabled: Boolean,\n    filter: Function,\n    hoverable: Boolean,\n    items: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    multipleActive: Boolean,\n    open: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    },\n    openAll: Boolean,\n    returnObject: {\n      type: Boolean,\n      default: false\n    },\n    search: String,\n    value: {\n      type: Array,\n      default: function _default() {\n        return [];\n      }\n    }\n  }, _VTreeviewNode.VTreeviewNodeProps),\n  data: function data() {\n    return {\n      level: -1,\n      activeCache: new Set(),\n      nodes: {},\n      openCache: new Set(),\n      selectedCache: new Set()\n    };\n  },\n  computed: {\n    excludedItems: function excludedItems() {\n      var excluded = new Set();\n      if (!this.search) return excluded;\n\n      for (var i = 0; i < this.items.length; i++) {\n        (0, _filterTreeItems.filterTreeItems)(this.filter || _filterTreeItems.filterTreeItem, this.items[i], this.search, this.itemKey, this.itemText, this.itemChildren, excluded);\n      }\n\n      return excluded;\n    }\n  },\n  watch: {\n    items: {\n      handler: function handler() {\n        var _this = this;\n\n        var oldKeys = Object.keys(this.nodes).map(function (k) {\n          return (0, _helpers.getObjectValueByPath)(_this.nodes[k].item, _this.itemKey);\n        });\n        var newKeys = this.getKeys(this.items);\n        var diff = (0, _helpers.arrayDiff)(newKeys, oldKeys); // We only want to do stuff if items have changed\n\n        if (!diff.length && newKeys.length < oldKeys.length) return; // If nodes are removed we need to clear them from this.nodes\n\n        diff.forEach(function (k) {\n          return delete _this.nodes[k];\n        });\n\n        var oldSelectedCache = _toConsumableArray(this.selectedCache);\n\n        this.selectedCache = new Set();\n        this.activeCache = new Set();\n        this.openCache = new Set();\n        this.buildTree(this.items); // Only emit selected if selection has changed\n        // as a result of items changing. This fixes a\n        // potential double emit when selecting a node\n        // with dynamic children\n\n        if (!(0, _helpers.deepEqual)(oldSelectedCache, _toConsumableArray(this.selectedCache))) this.emitSelected();\n      },\n      deep: true\n    },\n    active: function active(value) {\n      this.handleNodeCacheWatcher(value, this.activeCache, this.updateActive, this.emitActive);\n    },\n    value: function value(_value) {\n      this.handleNodeCacheWatcher(_value, this.selectedCache, this.updateSelected, this.emitSelected);\n    },\n    open: function open(value) {\n      this.handleNodeCacheWatcher(value, this.openCache, this.updateOpen, this.emitOpen);\n    }\n  },\n  created: function created() {\n    var _this2 = this;\n\n    var getValue = function getValue(key) {\n      return _this2.returnObject ? (0, _helpers.getObjectValueByPath)(key, _this2.itemKey) : key;\n    };\n\n    this.buildTree(this.items);\n\n    var _iterator = _createForOfIteratorHelper(this.value.map(getValue)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var value = _step.value;\n        this.updateSelected(value, true, true);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var _iterator2 = _createForOfIteratorHelper(this.active.map(getValue)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var active = _step2.value;\n        this.updateActive(active, true);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  },\n  mounted: function mounted() {\n    var _this3 = this; // Save the developer from themselves\n\n\n    if (this.$slots.prepend || this.$slots.append) {\n      (0, _console.consoleWarn)('The prepend and append slots require a slot-scope attribute', this);\n    }\n\n    if (this.openAll) {\n      this.updateAll(true);\n    } else {\n      this.open.forEach(function (key) {\n        return _this3.updateOpen(_this3.returnObject ? (0, _helpers.getObjectValueByPath)(key, _this3.itemKey) : key, true);\n      });\n      this.emitOpen();\n    }\n  },\n  methods: {\n    /** @public */\n    updateAll: function updateAll(value) {\n      var _this4 = this;\n\n      Object.keys(this.nodes).forEach(function (key) {\n        return _this4.updateOpen((0, _helpers.getObjectValueByPath)(_this4.nodes[key].item, _this4.itemKey), value);\n      });\n      this.emitOpen();\n    },\n    getKeys: function getKeys(items) {\n      var keys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      for (var i = 0; i < items.length; i++) {\n        var key = (0, _helpers.getObjectValueByPath)(items[i], this.itemKey);\n        keys.push(key);\n        var children = (0, _helpers.getObjectValueByPath)(items[i], this.itemChildren);\n\n        if (children) {\n          keys.push.apply(keys, _toConsumableArray(this.getKeys(children)));\n        }\n      }\n\n      return keys;\n    },\n    buildTree: function buildTree(items) {\n      var _this5 = this;\n\n      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      for (var i = 0; i < items.length; i++) {\n        var _getObjectValueByPath;\n\n        var item = items[i];\n        var key = (0, _helpers.getObjectValueByPath)(item, this.itemKey);\n        var children = (_getObjectValueByPath = (0, _helpers.getObjectValueByPath)(item, this.itemChildren)) != null ? _getObjectValueByPath : [];\n        var oldNode = this.nodes.hasOwnProperty(key) ? this.nodes[key] : {\n          isSelected: false,\n          isIndeterminate: false,\n          isActive: false,\n          isOpen: false,\n          vnode: null\n        };\n        var node = {\n          vnode: oldNode.vnode,\n          parent: parent,\n          children: children.map(function (c) {\n            return (0, _helpers.getObjectValueByPath)(c, _this5.itemKey);\n          }),\n          item: item\n        };\n        this.buildTree(children, key); // This fixed bug with dynamic children resetting selected parent state\n\n        if (this.selectionType !== 'independent' && parent !== null && !this.nodes.hasOwnProperty(key) && this.nodes.hasOwnProperty(parent)) {\n          node.isSelected = this.nodes[parent].isSelected;\n        } else {\n          node.isSelected = oldNode.isSelected;\n          node.isIndeterminate = oldNode.isIndeterminate;\n        }\n\n        node.isActive = oldNode.isActive;\n        node.isOpen = oldNode.isOpen;\n        this.nodes[key] = node;\n\n        if (children.length && this.selectionType !== 'independent') {\n          var _this$calculateState = this.calculateState(key, this.nodes),\n              isSelected = _this$calculateState.isSelected,\n              isIndeterminate = _this$calculateState.isIndeterminate;\n\n          node.isSelected = isSelected;\n          node.isIndeterminate = isIndeterminate;\n        } // Don't forget to rebuild cache\n\n\n        if (this.nodes[key].isSelected && (this.selectionType === 'independent' || node.children.length === 0)) this.selectedCache.add(key);\n        if (this.nodes[key].isActive) this.activeCache.add(key);\n        if (this.nodes[key].isOpen) this.openCache.add(key);\n        this.updateVnodeState(key);\n      }\n    },\n    calculateState: function calculateState(node, state) {\n      var children = state[node].children;\n      var counts = children.reduce(function (counts, child) {\n        counts[0] += +Boolean(state[child].isSelected);\n        counts[1] += +Boolean(state[child].isIndeterminate);\n        return counts;\n      }, [0, 0]);\n      var isSelected = !!children.length && counts[0] === children.length;\n      var isIndeterminate = !isSelected && (counts[0] > 0 || counts[1] > 0);\n      return {\n        isSelected: isSelected,\n        isIndeterminate: isIndeterminate\n      };\n    },\n    emitOpen: function emitOpen() {\n      this.emitNodeCache('update:open', this.openCache);\n    },\n    emitSelected: function emitSelected() {\n      this.emitNodeCache('input', this.selectedCache);\n    },\n    emitActive: function emitActive() {\n      this.emitNodeCache('update:active', this.activeCache);\n    },\n    emitNodeCache: function emitNodeCache(event, cache) {\n      var _this6 = this;\n\n      this.$emit(event, this.returnObject ? _toConsumableArray(cache).map(function (key) {\n        return _this6.nodes[key].item;\n      }) : _toConsumableArray(cache));\n    },\n    handleNodeCacheWatcher: function handleNodeCacheWatcher(value, cache, updateFn, emitFn) {\n      var _this7 = this;\n\n      value = this.returnObject ? value.map(function (v) {\n        return (0, _helpers.getObjectValueByPath)(v, _this7.itemKey);\n      }) : value;\n\n      var old = _toConsumableArray(cache);\n\n      if ((0, _helpers.deepEqual)(old, value)) return;\n      old.forEach(function (key) {\n        return updateFn(key, false);\n      });\n      value.forEach(function (key) {\n        return updateFn(key, true);\n      });\n      emitFn();\n    },\n    getDescendants: function getDescendants(key) {\n      var _descendants;\n\n      var descendants = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var children = this.nodes[key].children;\n\n      (_descendants = descendants).push.apply(_descendants, _toConsumableArray(children));\n\n      for (var i = 0; i < children.length; i++) {\n        descendants = this.getDescendants(children[i], descendants);\n      }\n\n      return descendants;\n    },\n    getParents: function getParents(key) {\n      var parent = this.nodes[key].parent;\n      var parents = [];\n\n      while (parent !== null) {\n        parents.push(parent);\n        parent = this.nodes[parent].parent;\n      }\n\n      return parents;\n    },\n    register: function register(node) {\n      var key = (0, _helpers.getObjectValueByPath)(node.item, this.itemKey);\n      this.nodes[key].vnode = node;\n      this.updateVnodeState(key);\n    },\n    unregister: function unregister(node) {\n      var key = (0, _helpers.getObjectValueByPath)(node.item, this.itemKey);\n      if (this.nodes[key]) this.nodes[key].vnode = null;\n    },\n    isParent: function isParent(key) {\n      return this.nodes[key].children && this.nodes[key].children.length;\n    },\n    updateActive: function updateActive(key, isActive) {\n      var _this8 = this;\n\n      if (!this.nodes.hasOwnProperty(key)) return;\n\n      if (!this.multipleActive) {\n        this.activeCache.forEach(function (active) {\n          _this8.nodes[active].isActive = false;\n\n          _this8.updateVnodeState(active);\n\n          _this8.activeCache.delete(active);\n        });\n      }\n\n      var node = this.nodes[key];\n      if (!node) return;\n      if (isActive) this.activeCache.add(key);else this.activeCache.delete(key);\n      node.isActive = isActive;\n      this.updateVnodeState(key);\n    },\n    updateSelected: function updateSelected(key, isSelected) {\n      var isForced = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (!this.nodes.hasOwnProperty(key)) return;\n      var changed = new Map();\n\n      if (this.selectionType !== 'independent') {\n        var _iterator3 = _createForOfIteratorHelper(this.getDescendants(key)),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var descendant = _step3.value;\n\n            if (!(0, _helpers.getObjectValueByPath)(this.nodes[descendant].item, this.itemDisabled) || isForced) {\n              this.nodes[descendant].isSelected = isSelected;\n              this.nodes[descendant].isIndeterminate = false;\n              changed.set(descendant, isSelected);\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        var calculated = this.calculateState(key, this.nodes);\n        this.nodes[key].isSelected = isSelected;\n        this.nodes[key].isIndeterminate = calculated.isIndeterminate;\n        changed.set(key, isSelected);\n\n        var _iterator4 = _createForOfIteratorHelper(this.getParents(key)),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var parent = _step4.value;\n\n            var _calculated = this.calculateState(parent, this.nodes);\n\n            this.nodes[parent].isSelected = _calculated.isSelected;\n            this.nodes[parent].isIndeterminate = _calculated.isIndeterminate;\n            changed.set(parent, _calculated.isSelected);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        this.nodes[key].isSelected = isSelected;\n        this.nodes[key].isIndeterminate = false;\n        changed.set(key, isSelected);\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(changed.entries()),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              _key = _step5$value[0],\n              value = _step5$value[1];\n\n          this.updateVnodeState(_key);\n          if (this.selectionType === 'leaf' && this.isParent(_key)) continue;\n          value === true ? this.selectedCache.add(_key) : this.selectedCache.delete(_key);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    },\n    updateOpen: function updateOpen(key, isOpen) {\n      var _this9 = this;\n\n      if (!this.nodes.hasOwnProperty(key)) return;\n      var node = this.nodes[key];\n      var children = (0, _helpers.getObjectValueByPath)(node.item, this.itemChildren);\n\n      if (children && !children.length && node.vnode && !node.vnode.hasLoaded) {\n        node.vnode.checkChildren().then(function () {\n          return _this9.updateOpen(key, isOpen);\n        });\n      } else if (children && children.length) {\n        node.isOpen = isOpen;\n        node.isOpen ? this.openCache.add(key) : this.openCache.delete(key);\n        this.updateVnodeState(key);\n      }\n    },\n    updateVnodeState: function updateVnodeState(key) {\n      var node = this.nodes[key];\n\n      if (node && node.vnode) {\n        node.vnode.isSelected = node.isSelected;\n        node.vnode.isIndeterminate = node.isIndeterminate;\n        node.vnode.isActive = node.isActive;\n        node.vnode.isOpen = node.isOpen;\n      }\n    },\n    isExcluded: function isExcluded(key) {\n      return !!this.search && this.excludedItems.has(key);\n    }\n  },\n  render: function render(h) {\n    var _this10 = this;\n\n    var children = this.items.length ? this.items.filter(function (item) {\n      return !_this10.isExcluded((0, _helpers.getObjectValueByPath)(item, _this10.itemKey));\n    }).map(function (item) {\n      var genChild = _VTreeviewNode.default.options.methods.genChild.bind(_this10);\n\n      return genChild(item, _this10.disabled || (0, _helpers.getObjectValueByPath)(item, _this10.itemDisabled));\n    })\n    /* istanbul ignore next */\n    : this.$slots.default; // TODO: remove type annotation with TS 3.2\n\n    return h('div', {\n      staticClass: 'v-treeview',\n      class: _objectSpread({\n        'v-treeview--hoverable': this.hoverable,\n        'v-treeview--dense': this.dense\n      }, this.themeClasses)\n    }, children);\n  }\n});\n\nexports.default = _default2;","map":{"version":3,"mappings":"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","names":["require","_themeable","extend","name","provide","treeview","props","active","type","Array","default","dense","Boolean","disabled","filter","Function","hoverable","items","multipleActive","open","openAll","returnObject","search","String","value","_VTreeviewNode","data","level","activeCache","Set","nodes","openCache","selectedCache","computed","excludedItems","excluded","i","length","_filterTreeItems","itemKey","itemText","itemChildren","watch","handler","oldKeys","Object","keys","map","_this","k","item","newKeys","getKeys","diff","forEach","oldSelectedCache","buildTree","emitSelected","deep","handleNodeCacheWatcher","updateActive","emitActive","_value","updateSelected","updateOpen","emitOpen","created","getValue","key","_this2","_iterator","_iterator2","mounted","$slots","prepend","append","updateAll","_this3","methods","_this4","push","children","_toConsumableArray","parent","oldNode","hasOwnProperty","isSelected","isIndeterminate","isActive","isOpen","vnode","node","c","_this5","selectionType","calculateState","add","updateVnodeState","state","counts","reduce","child","emitNodeCache","event","cache","$emit","_this6","updateFn","emitFn","v","_this7","old","getDescendants","descendants","getParents","parents","register","unregister","isParent","_this8","delete","isForced","changed","Map","descendant","itemDisabled","set","_iterator3","calculated","_calculated","_iterator4","entries","_key","_iterator5","hasLoaded","checkChildren","then","_this9","isExcluded","has","render","h","_this10","genChild","options","bind","staticClass","class","themeClasses"],"sourceRoot":"","sources":["../../../src/components/VTreeview/VTreeview.ts"],"sourcesContent":["// Styles\nimport './VTreeview.sass'\n\n// Types\nimport { VNode, VNodeChildrenArrayContents, PropType } from 'vue'\nimport { PropValidator } from 'vue/types/options'\nimport { TreeviewItemFunction } from 'vuetify/types'\n\n// Components\nimport VTreeviewNode, { VTreeviewNodeProps } from './VTreeviewNode'\n\n// Mixins\nimport Themeable from '../../mixins/themeable'\nimport { provide as RegistrableProvide } from '../../mixins/registrable'\n\n// Utils\nimport {\n  arrayDiff,\n  deepEqual,\n  getObjectValueByPath,\n} from '../../util/helpers'\nimport mixins from '../../util/mixins'\nimport { consoleWarn } from '../../util/console'\nimport {\n  filterTreeItems,\n  filterTreeItem,\n} from './util/filterTreeItems'\n\ntype VTreeviewNodeInstance = InstanceType<typeof VTreeviewNode>\n\ntype NodeCache = Set<string | number>\ntype NodeArray = (string | number)[]\n\ntype NodeState = {\n  parent: number | string | null\n  children: (number | string)[]\n  vnode: VTreeviewNodeInstance | null\n  isActive: boolean\n  isSelected: boolean\n  isIndeterminate: boolean\n  isOpen: boolean\n  item: any\n}\n\nexport default mixins(\n  RegistrableProvide('treeview'),\n  Themeable\n  /* @vue/component */\n).extend({\n  name: 'v-treeview',\n\n  provide (): object {\n    return { treeview: this }\n  },\n\n  props: {\n    active: {\n      type: Array,\n      default: () => ([]),\n    } as PropValidator<NodeArray>,\n    dense: Boolean,\n    disabled: Boolean,\n    filter: Function as PropType<TreeviewItemFunction>,\n    hoverable: Boolean,\n    items: {\n      type: Array,\n      default: () => ([]),\n    } as PropValidator<any[]>,\n    multipleActive: Boolean,\n    open: {\n      type: Array,\n      default: () => ([]),\n    } as PropValidator<NodeArray>,\n    openAll: Boolean,\n    returnObject: {\n      type: Boolean,\n      default: false, // TODO: Should be true in next major\n    },\n    search: String,\n    value: {\n      type: Array,\n      default: () => ([]),\n    } as PropValidator<NodeArray>,\n    ...VTreeviewNodeProps,\n  },\n\n  data: () => ({\n    level: -1,\n    activeCache: new Set() as NodeCache,\n    nodes: {} as Record<string | number, NodeState>,\n    openCache: new Set() as NodeCache,\n    selectedCache: new Set() as NodeCache,\n  }),\n\n  computed: {\n    excludedItems (): Set<string | number> {\n      const excluded = new Set<string|number>()\n\n      if (!this.search) return excluded\n\n      for (let i = 0; i < this.items.length; i++) {\n        filterTreeItems(\n          this.filter || filterTreeItem,\n          this.items[i],\n          this.search,\n          this.itemKey,\n          this.itemText,\n          this.itemChildren,\n          excluded\n        )\n      }\n\n      return excluded\n    },\n  },\n\n  watch: {\n    items: {\n      handler () {\n        const oldKeys = Object.keys(this.nodes).map(k => getObjectValueByPath(this.nodes[k].item, this.itemKey))\n        const newKeys = this.getKeys(this.items)\n        const diff = arrayDiff(newKeys, oldKeys)\n\n        // We only want to do stuff if items have changed\n        if (!diff.length && newKeys.length < oldKeys.length) return\n\n        // If nodes are removed we need to clear them from this.nodes\n        diff.forEach(k => delete this.nodes[k])\n\n        const oldSelectedCache = [...this.selectedCache]\n        this.selectedCache = new Set()\n        this.activeCache = new Set()\n        this.openCache = new Set()\n        this.buildTree(this.items)\n\n        // Only emit selected if selection has changed\n        // as a result of items changing. This fixes a\n        // potential double emit when selecting a node\n        // with dynamic children\n        if (!deepEqual(oldSelectedCache, [...this.selectedCache])) this.emitSelected()\n      },\n      deep: true,\n    },\n    active (value: (string | number | any)[]) {\n      this.handleNodeCacheWatcher(value, this.activeCache, this.updateActive, this.emitActive)\n    },\n    value (value: (string | number | any)[]) {\n      this.handleNodeCacheWatcher(value, this.selectedCache, this.updateSelected, this.emitSelected)\n    },\n    open (value: (string | number | any)[]) {\n      this.handleNodeCacheWatcher(value, this.openCache, this.updateOpen, this.emitOpen)\n    },\n  },\n\n  created () {\n    const getValue = (key: string | number) => this.returnObject ? getObjectValueByPath(key, this.itemKey) : key\n\n    this.buildTree(this.items)\n\n    for (const value of this.value.map(getValue)) {\n      this.updateSelected(value, true, true)\n    }\n\n    for (const active of this.active.map(getValue)) {\n      this.updateActive(active, true)\n    }\n  },\n\n  mounted () {\n    // Save the developer from themselves\n    if (this.$slots.prepend || this.$slots.append) {\n      consoleWarn('The prepend and append slots require a slot-scope attribute', this)\n    }\n\n    if (this.openAll) {\n      this.updateAll(true)\n    } else {\n      this.open.forEach(key => this.updateOpen(this.returnObject ? getObjectValueByPath(key, this.itemKey) : key, true))\n      this.emitOpen()\n    }\n  },\n\n  methods: {\n    /** @public */\n    updateAll (value: boolean) {\n      Object.keys(this.nodes).forEach(key => this.updateOpen(getObjectValueByPath(this.nodes[key].item, this.itemKey), value))\n      this.emitOpen()\n    },\n    getKeys (items: any[], keys: any[] = []) {\n      for (let i = 0; i < items.length; i++) {\n        const key = getObjectValueByPath(items[i], this.itemKey)\n        keys.push(key)\n        const children = getObjectValueByPath(items[i], this.itemChildren)\n        if (children) {\n          keys.push(...this.getKeys(children))\n        }\n      }\n\n      return keys\n    },\n    buildTree (items: any[], parent: (string | number | null) = null) {\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i]\n        const key = getObjectValueByPath(item, this.itemKey)\n        const children = getObjectValueByPath(item, this.itemChildren) ?? []\n        const oldNode = this.nodes.hasOwnProperty(key) ? this.nodes[key] : {\n          isSelected: false, isIndeterminate: false, isActive: false, isOpen: false, vnode: null,\n        } as NodeState\n\n        const node: any = {\n          vnode: oldNode.vnode,\n          parent,\n          children: children.map((c: any) => getObjectValueByPath(c, this.itemKey)),\n          item,\n        }\n\n        this.buildTree(children, key)\n\n        // This fixed bug with dynamic children resetting selected parent state\n        if (\n          this.selectionType !== 'independent' &&\n          parent !== null &&\n          !this.nodes.hasOwnProperty(key) &&\n          this.nodes.hasOwnProperty(parent)\n        ) {\n          node.isSelected = this.nodes[parent].isSelected\n        } else {\n          node.isSelected = oldNode.isSelected\n          node.isIndeterminate = oldNode.isIndeterminate\n        }\n\n        node.isActive = oldNode.isActive\n        node.isOpen = oldNode.isOpen\n\n        this.nodes[key] = node\n\n        if (children.length && this.selectionType !== 'independent') {\n          const { isSelected, isIndeterminate } = this.calculateState(key, this.nodes)\n\n          node.isSelected = isSelected\n          node.isIndeterminate = isIndeterminate\n        }\n\n        // Don't forget to rebuild cache\n        if (this.nodes[key].isSelected && (this.selectionType === 'independent' || node.children.length === 0)) this.selectedCache.add(key)\n        if (this.nodes[key].isActive) this.activeCache.add(key)\n        if (this.nodes[key].isOpen) this.openCache.add(key)\n\n        this.updateVnodeState(key)\n      }\n    },\n    calculateState (node: string | number, state: Record<string | number, NodeState>) {\n      const children = state[node].children\n      const counts = children.reduce((counts: number[], child: string | number) => {\n        counts[0] += +Boolean(state[child].isSelected)\n        counts[1] += +Boolean(state[child].isIndeterminate)\n\n        return counts\n      }, [0, 0])\n\n      const isSelected = !!children.length && counts[0] === children.length\n      const isIndeterminate = !isSelected && (counts[0] > 0 || counts[1] > 0)\n\n      return {\n        isSelected,\n        isIndeterminate,\n      }\n    },\n    emitOpen () {\n      this.emitNodeCache('update:open', this.openCache)\n    },\n    emitSelected () {\n      this.emitNodeCache('input', this.selectedCache)\n    },\n    emitActive () {\n      this.emitNodeCache('update:active', this.activeCache)\n    },\n    emitNodeCache (event: string, cache: NodeCache) {\n      this.$emit(event, this.returnObject ? [...cache].map(key => this.nodes[key].item) : [...cache])\n    },\n    handleNodeCacheWatcher (value: any[], cache: NodeCache, updateFn: Function, emitFn: Function) {\n      value = this.returnObject ? value.map(v => getObjectValueByPath(v, this.itemKey)) : value\n      const old = [...cache]\n      if (deepEqual(old, value)) return\n\n      old.forEach(key => updateFn(key, false))\n      value.forEach(key => updateFn(key, true))\n\n      emitFn()\n    },\n    getDescendants (key: string | number, descendants: NodeArray = []) {\n      const children = this.nodes[key].children\n\n      descendants.push(...children)\n\n      for (let i = 0; i < children.length; i++) {\n        descendants = this.getDescendants(children[i], descendants)\n      }\n\n      return descendants\n    },\n    getParents (key: string | number) {\n      let parent = this.nodes[key].parent\n\n      const parents = []\n      while (parent !== null) {\n        parents.push(parent)\n        parent = this.nodes[parent].parent\n      }\n\n      return parents\n    },\n    register (node: VTreeviewNodeInstance) {\n      const key = getObjectValueByPath(node.item, this.itemKey)\n      this.nodes[key].vnode = node\n\n      this.updateVnodeState(key)\n    },\n    unregister (node: VTreeviewNodeInstance) {\n      const key = getObjectValueByPath(node.item, this.itemKey)\n      if (this.nodes[key]) this.nodes[key].vnode = null\n    },\n    isParent (key: string | number) {\n      return this.nodes[key].children && this.nodes[key].children.length\n    },\n    updateActive (key: string | number, isActive: boolean) {\n      if (!this.nodes.hasOwnProperty(key)) return\n\n      if (!this.multipleActive) {\n        this.activeCache.forEach(active => {\n          this.nodes[active].isActive = false\n          this.updateVnodeState(active)\n          this.activeCache.delete(active)\n        })\n      }\n\n      const node = this.nodes[key]\n      if (!node) return\n\n      if (isActive) this.activeCache.add(key)\n      else this.activeCache.delete(key)\n\n      node.isActive = isActive\n\n      this.updateVnodeState(key)\n    },\n    updateSelected (key: string | number, isSelected: boolean, isForced = false) {\n      if (!this.nodes.hasOwnProperty(key)) return\n\n      const changed = new Map()\n\n      if (this.selectionType !== 'independent') {\n        for (const descendant of this.getDescendants(key)) {\n          if (!getObjectValueByPath(this.nodes[descendant].item, this.itemDisabled) || isForced) {\n            this.nodes[descendant].isSelected = isSelected\n            this.nodes[descendant].isIndeterminate = false\n            changed.set(descendant, isSelected)\n          }\n        }\n\n        const calculated = this.calculateState(key, this.nodes)\n        this.nodes[key].isSelected = isSelected\n        this.nodes[key].isIndeterminate = calculated.isIndeterminate\n        changed.set(key, isSelected)\n\n        for (const parent of this.getParents(key)) {\n          const calculated = this.calculateState(parent, this.nodes)\n          this.nodes[parent].isSelected = calculated.isSelected\n          this.nodes[parent].isIndeterminate = calculated.isIndeterminate\n          changed.set(parent, calculated.isSelected)\n        }\n      } else {\n        this.nodes[key].isSelected = isSelected\n        this.nodes[key].isIndeterminate = false\n        changed.set(key, isSelected)\n      }\n\n      for (const [key, value] of changed.entries()) {\n        this.updateVnodeState(key)\n\n        if (this.selectionType === 'leaf' && this.isParent(key)) continue\n\n        value === true ? this.selectedCache.add(key) : this.selectedCache.delete(key)\n      }\n    },\n    updateOpen (key: string | number, isOpen: boolean) {\n      if (!this.nodes.hasOwnProperty(key)) return\n\n      const node = this.nodes[key]\n      const children = getObjectValueByPath(node.item, this.itemChildren)\n\n      if (children && !children.length && node.vnode && !node.vnode.hasLoaded) {\n        node.vnode.checkChildren().then(() => this.updateOpen(key, isOpen))\n      } else if (children && children.length) {\n        node.isOpen = isOpen\n\n        node.isOpen ? this.openCache.add(key) : this.openCache.delete(key)\n\n        this.updateVnodeState(key)\n      }\n    },\n    updateVnodeState (key: string | number) {\n      const node = this.nodes[key]\n\n      if (node && node.vnode) {\n        node.vnode.isSelected = node.isSelected\n        node.vnode.isIndeterminate = node.isIndeterminate\n        node.vnode.isActive = node.isActive\n        node.vnode.isOpen = node.isOpen\n      }\n    },\n    isExcluded (key: string | number) {\n      return !!this.search && this.excludedItems.has(key)\n    },\n  },\n\n  render (h): VNode {\n    const children: VNodeChildrenArrayContents = this.items.length\n      ? this.items.filter(item => {\n        return !this.isExcluded(getObjectValueByPath(item, this.itemKey))\n      }).map(item => {\n        const genChild = VTreeviewNode.options.methods.genChild.bind(this)\n\n        return genChild(item, this.disabled || getObjectValueByPath(item, this.itemDisabled))\n      })\n      /* istanbul ignore next */\n      : this.$slots.default! // TODO: remove type annotation with TS 3.2\n\n    return h('div', {\n      staticClass: 'v-treeview',\n      class: {\n        'v-treeview--hoverable': this.hoverable,\n        'v-treeview--dense': this.dense,\n        ...this.themeClasses,\n      },\n    }, children)\n  },\n})\n"]},"metadata":{},"sourceType":"script"}