{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.object.keys.js\");\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.array.filter.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptors.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.string.split.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parsedCategoryText = parsedCategoryText;\nexports.getParsedCategories = getParsedCategories;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction parsedCategoryText(category, categoryText) {\n  return typeof categoryText === 'string' && _typeof(category) === 'object' && category ? category[categoryText] : typeof categoryText === 'function' ? categoryText(category) : category;\n}\n\nfunction getParsedCategories(categories, categoryText) {\n  if (typeof categories === 'string') return categories.split(/\\s*,\\s/);\n\n  if (Array.isArray(categories)) {\n    return categories.map(function (category) {\n      if (typeof category === 'string') return category;\n      var categoryName = typeof category.categoryName === 'string' ? category.categoryName : parsedCategoryText(category, categoryText);\n      return _objectSpread(_objectSpread({}, category), {}, {\n        categoryName: categoryName\n      });\n    });\n  }\n\n  return [];\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEM,SAAUA,kBAAV,CACJC,QADI,EAEJC,YAFI,EAE+C;EAEnD,OAAO,OAAOA,YAAP,KAAwB,QAAxB,IAAoCC,QAAOF,QAAP,MAAoB,QAAxD,IAAoEA,QAApE,GACHA,QAAQ,CAACC,YAAD,CADL,GAEH,OAAOA,YAAP,KAAwB,UAAxB,GACEA,YAAY,CAACD,QAAD,CADd,GAEEA,QAJN;AAKD;;AAEK,SAAUG,mBAAV,CACJC,UADI,EAEJH,YAFI,EAE+C;EAEnD,IAAI,OAAOG,UAAP,KAAsB,QAA1B,EAAoC,OAAOA,UAAU,CAACC,KAAX,CAAiB,QAAjB,CAAP;;EACpC,IAAIC,KAAK,CAACC,OAAN,CAAcH,UAAd,CAAJ,EAA+B;IAC7B,OAAOA,UAAU,CAACI,GAAX,CAAe,UAACR,QAAD,EAA+B;MACnD,IAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC,OAAOA,QAAP;MAElC,IAAMS,YAAY,GAAG,OAAOT,QAAQ,CAACS,YAAhB,KAAiC,QAAjC,GACjBT,QAAQ,CAACS,YADQ,GAEjBV,kBAAkB,CAACC,QAAD,EAAWC,YAAX,CAFtB;MAGA,uCAAYD,QAAZ;QAAsBS,YAAY,EAAZA;MAAtB;IANK,EAAP;EAQD;;EACD,OAAO,EAAP;AACD","names":["parsedCategoryText","category","categoryText","_typeof","getParsedCategories","categories","split","Array","isArray","map","categoryName"],"sourceRoot":"","sources":["../../../../src/components/VCalendar/util/parser.ts"],"sourcesContent":["import { CalendarCategory, CalendarCategoryTextFunction } from 'types'\n\nexport function parsedCategoryText (\n  category: CalendarCategory,\n  categoryText: string | CalendarCategoryTextFunction\n): string {\n  return typeof categoryText === 'string' && typeof category === 'object' && category\n    ? category[categoryText]\n    : typeof categoryText === 'function'\n      ? categoryText(category)\n      : category\n}\n\nexport function getParsedCategories (\n  categories: CalendarCategory | CalendarCategory[],\n  categoryText: string | CalendarCategoryTextFunction\n): CalendarCategory[] {\n  if (typeof categories === 'string') return categories.split(/\\s*,\\s/)\n  if (Array.isArray(categories)) {\n    return categories.map((category: CalendarCategory) => {\n      if (typeof category === 'string') return category\n\n      const categoryName = typeof category.categoryName === 'string'\n        ? category.categoryName\n        : parsedCategoryText(category, categoryText)\n      return { ...category, categoryName }\n    })\n  }\n  return []\n}\n"]},"metadata":{},"sourceType":"script"}