{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\nrequire(\"core-js/modules/es.string.includes.js\");\n\nrequire(\"core-js/modules/es.array.from.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _bootable = _interopRequireDefault(require(\"../bootable\"));\n\nvar _helpers = require(\"../../util/helpers\");\n\nvar _mixins = _interopRequireDefault(require(\"../../util/mixins\"));\n\nvar _console = require(\"../../util/console\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction validateAttachTarget(val) {\n  var type = _typeof(val);\n\n  if (type === 'boolean' || type === 'string') return true;\n  return val.nodeType === Node.ELEMENT_NODE;\n}\n\nfunction removeActivator(activator) {\n  activator.forEach(function (node) {\n    node.elm && node.elm.parentNode && node.elm.parentNode.removeChild(node.elm);\n  });\n}\n/* @vue/component */\n\n\nvar _default = (0, _mixins.default)(_bootable.default).extend({\n  name: 'detachable',\n  props: {\n    attach: {\n      default: false,\n      validator: validateAttachTarget\n    },\n    contentClass: {\n      type: String,\n      default: ''\n    }\n  },\n  data: function data() {\n    return {\n      activatorNode: null,\n      hasDetached: false\n    };\n  },\n  watch: {\n    attach: function attach() {\n      this.hasDetached = false;\n      this.initDetach();\n    },\n    hasContent: function hasContent() {\n      this.$nextTick(this.initDetach);\n    }\n  },\n  beforeMount: function beforeMount() {\n    var _this = this;\n\n    this.$nextTick(function () {\n      if (_this.activatorNode) {\n        var activator = Array.isArray(_this.activatorNode) ? _this.activatorNode : [_this.activatorNode];\n        activator.forEach(function (node) {\n          if (!node.elm) return;\n          if (!_this.$el.parentNode) return;\n          var target = _this.$el === _this.$el.parentNode.firstChild ? _this.$el : _this.$el.nextSibling;\n\n          _this.$el.parentNode.insertBefore(node.elm, target);\n        });\n      }\n    });\n  },\n  mounted: function mounted() {\n    this.hasContent && this.initDetach();\n  },\n  deactivated: function deactivated() {\n    this.isActive = false;\n  },\n  beforeDestroy: function beforeDestroy() {\n    if (this.$refs.content && this.$refs.content.parentNode) {\n      this.$refs.content.parentNode.removeChild(this.$refs.content);\n    }\n  },\n  destroyed: function destroyed() {\n    var _this2 = this;\n\n    if (this.activatorNode) {\n      var activator = Array.isArray(this.activatorNode) ? this.activatorNode : [this.activatorNode];\n\n      if (this.$el.isConnected) {\n        // Component has been destroyed but the element still exists, we must be in a transition\n        // Wait for the transition to finish before cleaning up the detached activator\n        var observer = new MutationObserver(function (list) {\n          if (list.some(function (record) {\n            return Array.from(record.removedNodes).includes(_this2.$el);\n          })) {\n            observer.disconnect();\n            removeActivator(activator);\n          }\n        });\n        observer.observe(this.$el.parentNode, {\n          subtree: false,\n          childList: true\n        });\n      } else {\n        removeActivator(activator);\n      }\n    }\n  },\n  methods: {\n    getScopeIdAttrs: function getScopeIdAttrs() {\n      var scopeId = (0, _helpers.getObjectValueByPath)(this.$vnode, 'context.$options._scopeId');\n      return scopeId && _defineProperty({}, scopeId, '');\n    },\n    initDetach: function initDetach() {\n      if (this._isDestroyed || !this.$refs.content || this.hasDetached || // Leave menu in place if attached\n      // and dev has not changed target\n      this.attach === '' || // If used as a boolean prop (<v-menu attach>)\n      this.attach === true || // If bound to a boolean (<v-menu :attach=\"true\">)\n      this.attach === 'attach' // If bound as boolean prop in pug (v-menu(attach))\n      ) return;\n      var target;\n\n      if (this.attach === false) {\n        // Default, detach to app\n        target = document.querySelector('[data-app]');\n      } else if (typeof this.attach === 'string') {\n        // CSS selector\n        target = document.querySelector(this.attach);\n      } else {\n        // DOM Element\n        target = this.attach;\n      }\n\n      if (!target) {\n        (0, _console.consoleWarn)(\"Unable to locate target \".concat(this.attach || '[data-app]'), this);\n        return;\n      }\n\n      target.appendChild(this.$refs.content);\n      this.hasDetached = true;\n    }\n  }\n});\n\nexports.default = _default;","map":{"version":3,"mappings":"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","names":["validateAttachTarget","val","type","nodeType","Node","ELEMENT_NODE","removeActivator","activator","forEach","node","elm","parentNode","removeChild","_bootable","extend","name","props","attach","default","validator","contentClass","String","data","activatorNode","hasDetached","watch","initDetach","hasContent","$nextTick","beforeMount","_this","Array","isArray","$el","target","firstChild","nextSibling","insertBefore","mounted","deactivated","isActive","beforeDestroy","$refs","content","destroyed","isConnected","observer","MutationObserver","list","some","from","record","removedNodes","includes","_this2","disconnect","observe","subtree","childList","methods","getScopeIdAttrs","scopeId","$vnode","_isDestroyed","document","querySelector","appendChild"],"sourceRoot":"","sources":["../../../src/mixins/detachable/index.ts"],"sourcesContent":["// Mixins\nimport Bootable from '../bootable'\n\n// Utilities\nimport { getObjectValueByPath } from '../../util/helpers'\nimport mixins, { ExtractVue } from '../../util/mixins'\nimport { consoleWarn } from '../../util/console'\n\n// Types\nimport Vue, { PropOptions } from 'vue'\nimport { VNode } from 'vue/types'\n\ninterface options extends Vue {\n  $el: HTMLElement\n  $refs: {\n    content: HTMLElement\n  }\n}\n\nfunction validateAttachTarget (val: any) {\n  const type = typeof val\n\n  if (type === 'boolean' || type === 'string') return true\n\n  return val.nodeType === Node.ELEMENT_NODE\n}\n\nfunction removeActivator (activator: VNode[]) {\n  activator.forEach(node => {\n    node.elm &&\n    node.elm.parentNode &&\n    node.elm.parentNode.removeChild(node.elm)\n  })\n}\n\n/* @vue/component */\nexport default mixins<options &\n  /* eslint-disable indent */\n  ExtractVue<typeof Bootable>\n  /* eslint-enable indent */\n>(Bootable).extend({\n  name: 'detachable',\n\n  props: {\n    attach: {\n      default: false,\n      validator: validateAttachTarget,\n    } as PropOptions<boolean | string | Element>,\n    contentClass: {\n      type: String,\n      default: '',\n    },\n  },\n\n  data: () => ({\n    activatorNode: null as null | VNode | VNode[],\n    hasDetached: false,\n  }),\n\n  watch: {\n    attach () {\n      this.hasDetached = false\n      this.initDetach()\n    },\n    hasContent () {\n      this.$nextTick(this.initDetach)\n    },\n  },\n\n  beforeMount () {\n    this.$nextTick(() => {\n      if (this.activatorNode) {\n        const activator = Array.isArray(this.activatorNode) ? this.activatorNode : [this.activatorNode]\n\n        activator.forEach(node => {\n          if (!node.elm) return\n          if (!this.$el.parentNode) return\n\n          const target = this.$el === this.$el.parentNode.firstChild\n            ? this.$el\n            : this.$el.nextSibling\n\n          this.$el.parentNode.insertBefore(node.elm, target)\n        })\n      }\n    })\n  },\n\n  mounted () {\n    this.hasContent && this.initDetach()\n  },\n\n  deactivated () {\n    this.isActive = false\n  },\n\n  beforeDestroy () {\n    if (\n      this.$refs.content &&\n      this.$refs.content.parentNode\n    ) {\n      this.$refs.content.parentNode.removeChild(this.$refs.content)\n    }\n  },\n\n  destroyed () {\n    if (this.activatorNode) {\n      const activator = Array.isArray(this.activatorNode) ? this.activatorNode : [this.activatorNode]\n      if (this.$el.isConnected) {\n        // Component has been destroyed but the element still exists, we must be in a transition\n        // Wait for the transition to finish before cleaning up the detached activator\n        const observer = new MutationObserver(list => {\n          if (\n            list.some(record => Array.from(record.removedNodes).includes(this.$el))\n          ) {\n            observer.disconnect()\n            removeActivator(activator)\n          }\n        })\n        observer.observe(this.$el.parentNode!, { subtree: false, childList: true })\n      } else {\n        removeActivator(activator)\n      }\n    }\n  },\n\n  methods: {\n    getScopeIdAttrs () {\n      const scopeId = getObjectValueByPath(this.$vnode, 'context.$options._scopeId')\n\n      return scopeId && {\n        [scopeId]: '',\n      }\n    },\n    initDetach () {\n      if (this._isDestroyed ||\n        !this.$refs.content ||\n        this.hasDetached ||\n        // Leave menu in place if attached\n        // and dev has not changed target\n        this.attach === '' || // If used as a boolean prop (<v-menu attach>)\n        this.attach === true || // If bound to a boolean (<v-menu :attach=\"true\">)\n        this.attach === 'attach' // If bound as boolean prop in pug (v-menu(attach))\n      ) return\n\n      let target\n      if (this.attach === false) {\n        // Default, detach to app\n        target = document.querySelector('[data-app]')\n      } else if (typeof this.attach === 'string') {\n        // CSS selector\n        target = document.querySelector(this.attach)\n      } else {\n        // DOM Element\n        target = this.attach\n      }\n\n      if (!target) {\n        consoleWarn(`Unable to locate target ${this.attach || '[data-app]'}`, this)\n        return\n      }\n\n      target.appendChild(this.$refs.content)\n\n      this.hasDetached = true\n    },\n  },\n})\n"]},"metadata":{},"sourceType":"script"}