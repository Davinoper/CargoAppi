{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.object.keys.js\");\n\nrequire(\"core-js/modules/es.symbol.js\");\n\nrequire(\"core-js/modules/es.array.filter.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptor.js\");\n\nrequire(\"core-js/modules/web.dom-collections.for-each.js\");\n\nrequire(\"core-js/modules/es.object.get-own-property-descriptors.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.symbol.description.js\");\n\nrequire(\"core-js/modules/es.symbol.iterator.js\");\n\nrequire(\"core-js/modules/es.string.iterator.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.from.js\");\n\nrequire(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.regexp.test.js\");\n\nrequire(\"core-js/modules/es.string.split.js\");\n\nrequire(\"core-js/modules/es.string.trim.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = mergeData;\nexports.mergeStyles = mergeStyles;\nexports.mergeClasses = mergeClasses;\nexports.mergeListeners = mergeListeners;\n\nvar _helpers = require(\"./helpers\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e2) {\n          throw _e2;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e3) {\n      didErr = true;\n      err = _e3;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/\n};\n\nfunction parseStyle(style) {\n  var styleMap = {};\n\n  var _iterator = _createForOfIteratorHelper(style.split(pattern.styleList)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var s = _step.value;\n\n      var _s$split = s.split(pattern.styleProp),\n          _s$split2 = _slicedToArray(_s$split, 2),\n          key = _s$split2[0],\n          val = _s$split2[1];\n\n      key = key.trim();\n\n      if (!key) {\n        continue;\n      } // May be undefined if the `key: value` pair is incomplete.\n\n\n      if (typeof val === 'string') {\n        val = val.trim();\n      }\n\n      styleMap[(0, _helpers.camelize)(key)] = val;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return styleMap;\n}\n\nfunction mergeData() {\n  var mergeTarget = {};\n  var i = arguments.length;\n  var prop; // Allow for variadic argument length.\n\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (var _i2 = 0, _Object$keys = Object.keys(arguments[i]); _i2 < _Object$keys.length; _i2++) {\n      prop = _Object$keys[_i2];\n\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n        // Space delimited string concatenation strategy\n\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = '';\n          }\n\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' ';\n          }\n\n          mergeTarget[prop] += arguments[i][prop].trim();\n          break;\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop]);\n          }\n\n          break;\n        // Object merge strategy\n\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break;\n          }\n\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {};\n          }\n\n          mergeTarget[prop] = _objectSpread(_objectSpread({}, arguments[i][prop]), mergeTarget[prop]);\n          break;\n        // Reassignment strategy (no merge)\n\n        default:\n          // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop];\n          }\n\n      }\n    }\n  }\n\n  return mergeTarget;\n}\n\nfunction mergeStyles(target, source) {\n  if (!target) return source;\n  if (!source) return target;\n  target = (0, _helpers.wrapInArray)(typeof target === 'string' ? parseStyle(target) : target);\n  return target.concat(typeof source === 'string' ? parseStyle(source) : source);\n}\n\nfunction mergeClasses(target, source) {\n  if (!source) return target;\n  if (!target) return source;\n  return target ? (0, _helpers.wrapInArray)(target).concat(source) : source;\n}\n\nfunction mergeListeners() {\n  if (!(arguments.length <= 0 ? undefined : arguments[0])) return arguments.length <= 1 ? undefined : arguments[1];\n  if (!(arguments.length <= 1 ? undefined : arguments[1])) return arguments.length <= 0 ? undefined : arguments[0];\n  var dest = {};\n\n  for (var i = 2; i--;) {\n    var arg = i < 0 || arguments.length <= i ? undefined : arguments[i];\n\n    for (var event in arg) {\n      if (!arg[event]) continue;\n\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = [].concat(arg[event], dest[event]);\n      } else {\n        // Straight assign.\n        dest[event] = arg[event];\n      }\n    }\n  }\n\n  return dest;\n}","map":{"version":3,"mappings":"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","names":["pattern","styleList","styleProp","parseStyle","style","styleMap","split","s","key","val","trim","_iterator","mergeData","mergeTarget","i","arguments","length","prop","Object","keys","mergeClasses","mergeStyles","undefined","mergeListeners","target","source","concat","dest","arg","event"],"sourceRoot":"","sources":["../../src/util/mergeData.ts"],"sourcesContent":["/**\n * @copyright 2017 Alex Regan\n * @license MIT\n * @see https://github.com/alexsasharegan/vue-functional-data-merge\n */\n/* eslint-disable max-statements */\nimport { VNodeData } from 'vue'\nimport { camelize, wrapInArray } from './helpers'\n\nconst pattern = {\n  styleList: /;(?![^(]*\\))/g,\n  styleProp: /:(.*)/,\n} as const\n\nfunction parseStyle (style: string) {\n  const styleMap: Dictionary<any> = {}\n\n  for (const s of style.split(pattern.styleList)) {\n    let [key, val] = s.split(pattern.styleProp)\n    key = key.trim()\n    if (!key) {\n      continue\n    }\n    // May be undefined if the `key: value` pair is incomplete.\n    if (typeof val === 'string') {\n      val = val.trim()\n    }\n    styleMap[camelize(key)] = val\n  }\n\n  return styleMap\n}\n\n/**\n * Intelligently merges data for createElement.\n * Merges arguments left to right, preferring the right argument.\n * Returns new VNodeData object.\n */\nexport default function mergeData (...vNodeData: VNodeData[]): VNodeData\nexport default function mergeData (): VNodeData {\n  const mergeTarget: VNodeData & Dictionary<any> = {}\n  let i: number = arguments.length\n  let prop: string\n\n  // Allow for variadic argument length.\n  while (i--) {\n    // Iterate through the data properties and execute merge strategies\n    // Object.keys eliminates need for hasOwnProperty call\n    for (prop of Object.keys(arguments[i])) {\n      switch (prop) {\n        // Array merge strategy (array concatenation)\n        case 'class':\n        case 'directives':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeClasses(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        case 'style':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeStyles(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Space delimited string concatenation strategy\n        case 'staticClass':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (mergeTarget[prop] === undefined) {\n            mergeTarget[prop] = ''\n          }\n          if (mergeTarget[prop]) {\n            // Not an empty string, so concatenate\n            mergeTarget[prop] += ' '\n          }\n          mergeTarget[prop] += arguments[i][prop].trim()\n          break\n        // Object, the properties of which to merge via array merge strategy (array concatenation).\n        // Callback merge strategy merges callbacks to the beginning of the array,\n        // so that the last defined callback will be invoked first.\n        // This is done since to mimic how Object.assign merging\n        // uses the last given value to assign.\n        case 'on':\n        case 'nativeOn':\n          if (arguments[i][prop]) {\n            mergeTarget[prop] = mergeListeners(mergeTarget[prop], arguments[i][prop])\n          }\n          break\n        // Object merge strategy\n        case 'attrs':\n        case 'props':\n        case 'domProps':\n        case 'scopedSlots':\n        case 'staticStyle':\n        case 'hook':\n        case 'transition':\n          if (!arguments[i][prop]) {\n            break\n          }\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = {}\n          }\n          mergeTarget[prop] = { ...arguments[i][prop], ...mergeTarget[prop] }\n          break\n        // Reassignment strategy (no merge)\n        default: // slot, key, ref, tag, show, keepAlive\n          if (!mergeTarget[prop]) {\n            mergeTarget[prop] = arguments[i][prop]\n          }\n      }\n    }\n  }\n\n  return mergeTarget\n}\n\nexport function mergeStyles (\n  target: undefined | string | object[] | object,\n  source: undefined | string | object[] | object\n) {\n  if (!target) return source\n  if (!source) return target\n\n  target = wrapInArray(typeof target === 'string' ? parseStyle(target) : target)\n\n  return (target as object[]).concat(typeof source === 'string' ? parseStyle(source) : source)\n}\n\nexport function mergeClasses (target: any, source: any) {\n  if (!source) return target\n  if (!target) return source\n\n  return target ? wrapInArray(target).concat(source) : source\n}\n\nexport function mergeListeners (...args: [\n  { [key: string]: Function | Function[] } | undefined,\n  { [key: string]: Function | Function[] } | undefined\n]) {\n  if (!args[0]) return args[1]\n  if (!args[1]) return args[0]\n\n  const dest: { [key: string]: Function | Function[] } = {}\n\n  for (let i = 2; i--;) {\n    const arg = args[i]\n    for (const event in arg) {\n      if (!arg[event]) continue\n\n      if (dest[event]) {\n        // Merge current listeners before (because we are iterating backwards).\n        // Note that neither \"target\" or \"source\" must be altered.\n        dest[event] = ([] as Function[]).concat(arg[event], dest[event])\n      } else {\n        // Straight assign.\n        dest[event] = arg[event]\n      }\n    }\n  }\n\n  return dest\n}\n"]},"metadata":{},"sourceType":"script"}